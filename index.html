<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chatbot</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="An interactive AI Chatbot that supports text and voice input, image uploads, and saves chat history.">
    <meta name="keywords" content="AI chatbot, conversational AI, voice input, image upload, chat history, generative AI, natural language processing, mahidhar AI Chatbot">
    <link rel="canonical" href="https://mahidhar-projects.github.io/AI-Chatbot/">

    <!-- Open Graph / Facebook / LinkedIn -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mahidhar-projects.github.io/AI-Chatbot/">
    <meta property="og:title" content="AI Chatbot - Your Smart Conversational Assistant">
    <meta property="og:description" content="An interactive AI Chatbot that supports text and voice input, image uploads, and saves chat history.">
    <meta property="og:image" content="https://mahidhar-projects.github.io/AI-Chatbot/preview.png"> <!-- Replace with an actual preview image URL if you have one -->

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mahidhar-projects.github.io/AI-Chatbot/">
    <meta property="twitter:title" content="AI Chatbot - Your Smart Conversational Assistant">
    <meta property="twitter:description" content="An interactive AI Chatbot that supports text and voice input, image uploads, and saves chat history.">
    <meta property="twitter:image" content="https://mahidhar-projects.github.io/AI-Chatbot/preview.png"> <!-- Replace with an actual preview image URL if you have one -->

    <!-- Favicon -->
    <link rel="icon" href="https://mahidhar-projects.github.io/AI-Chatbot/favicon.ico" type="image/x-icon"> <!-- Replace with your actual favicon URL -->

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind CSS for dark mode
        tailwind.config = {
            darkMode: 'class', // Enable dark mode based on 'dark' class on <html>
            theme: {
                extend: {
                    colors: {
                        // Define custom colors or extend existing ones if needed
                    }
                }
            }
        }
    </script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4CKHSH30E3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-4CKHSH30E3');
    </script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-track {
            background: #333;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #555;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .dark ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body class="flex h-screen bg-gray-100 antialiased dark:bg-gray-900 dark:text-gray-100">

    <!-- Sidebar -->
    <div id="sidebar" class="fixed inset-y-0 left-0 w-64 bg-gray-800 text-white p-4 transform -translate-x-full md:relative md:translate-x-0 transition-transform duration-300 ease-in-out flex flex-col z-20 shadow-lg dark:bg-gray-950">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">History</h2>
            <button id="sidebar-close-button" class="md:hidden p-2 rounded-full hover:bg-gray-700 dark:hover:bg-gray-800">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-6 h-6">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <button id="new-chat-button" class="w-full mb-4 py-3 px-4 bg-indigo-600 rounded-lg font-semibold hover:bg-indigo-700 transition duration-200 flex items-center justify-center space-x-2 shadow-md">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-5 h-5">
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
            </svg>
            <span>New Chat</span>
        </button>

        <!-- Search History Input -->
        <div class="mb-4">
            <input type="text" id="search-history-input" placeholder="Search chats..." class="w-full p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:border-gray-700">
        </div>

        <div id="history-list" class="flex-1 overflow-y-auto">
            <!-- Chat history items will be rendered here by JavaScript -->
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="flex-1 flex flex-col">
        <header class="bg-gradient-to-r from-teal-500 to-blue-600 text-white p-5 shadow-xl rounded-b-xl flex justify-between items-center">
            <button id="sidebar-open-button" class="md:hidden p-2 rounded-full hover:bg-teal-600">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-6 h-6">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                </svg>
            </button>
            <h1 class="text-3xl font-extrabold tracking-wide flex-grow text-center">AI Chatbot</h1>
            <div class="flex items-center space-x-3">
                <!-- Language Selector -->
                <select id="language-select" class="bg-teal-600 text-white p-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-white dark:bg-blue-700">
                    <option value="en-US">English</option>
                    <option value="es-ES">Espa√±ol</option>
                    <!-- Add more languages as needed -->
                </select>

                <!-- Dark Mode Toggle -->
                <button id="dark-mode-toggle" class="p-2 rounded-full bg-teal-600 hover:bg-teal-700 text-white focus:outline-none focus:ring-2 focus:ring-white dark:bg-blue-700 dark:hover:bg-blue-800">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-6 h-6 sun-icon">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v1m0 16v1m9-9h1M3 12H2m15.325-4.725l-.707-.707M6.382 6.382l-.707-.707M17.617 17.617l-.707.707M6.382 17.617l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-6 h-6 moon-icon hidden">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25c0 5.385 4.365 9.75 9.75 9.75 2.012 0 3.904-.623 5.463-1.698z" />
                    </svg>
                </button>
            </div>
        </header>

        <main id="chat-messages-container" class="flex-1 overflow-y-auto p-6 space-y-4 max-w-3xl mx-auto w-full bg-gray-100 dark:bg-gray-800">
            <!-- Chat messages will be rendered here by JavaScript -->
            <div id="initial-message" class="text-center text-gray-500 mt-20 p-4 bg-white rounded-lg shadow-md border border-gray-200 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-300">
                <h2 class="text-xl font-bold text-gray-700 mb-2 dark:text-gray-100">Welcome to AI Chatbot!</h2>
                <p class="text-base">Start a conversation by typing a message below.</p>
            </div>
        </main>

        <footer class="p-4 bg-white shadow-2xl rounded-t-xl max-w-3xl mx-auto w-full dark:bg-gray-900">
            <div id="staged-image-preview-container">
                <!-- Staged image preview will be rendered here by JavaScript -->
            </div>

            <div class="flex items-center space-x-3">
                <!-- Hidden file input -->
                <input type="file" id="file-input" class="hidden" accept="image/*">
                <!-- Plus icon button to trigger file input -->
                <button id="add-media-button" class="p-3 bg-gray-200 text-gray-600 rounded-full shadow-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105 flex items-center justify-center dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" title="Add image">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fillRule="evenodd" d="M12 3.75a.75.75 0 0 1 .75.75v6.75h6.75a.75.75 0 0 1 0 1.5h-6.75v6.75a.75.75 0 0 1-1.5 0v-6.75H4.5a.75.75 0 0 1 0-1.5h6.75V4.5a.75.75 0 0 1 .75-.75Z" clipRule="evenodd" />
                    </svg>
                </button>

                <button id="mic-button" class="p-3 bg-purple-500 text-white rounded-full shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.2-3c0 3.53-2.64 6.4-6.2 6.73V21h-1.5v-3.27C6.44 17.4 3.8 14.53 3.8 11H2c0 3.98 3.15 7.22 7.07 7.68V21h4.28v-3.32c3.92-.46 7.07-3.7 7.07-7.68h-1.7zm-4.39-2.81l-1.41 1.41-2.83-2.83 1.41-1.41 2.83 2.83z"/>
                    </svg>
                </button>

                <textarea id="input-textarea" class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none min-h-[48px] max-h-[96px] overflow-y-auto transition-all duration-200 ease-in-out shadow-inner focus:shadow-md dark:bg-gray-800 dark:border-gray-600 dark:text-gray-100" placeholder="Type your message..." rows="1"></textarea>
                <button id="send-button" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition duration-200 ease-in-out transform hover:scale-105 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                        <path d="M3.478 2.405a.75.75 0 0 0-.926.94l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.542 60.542 0 0 0 18.443-8.688.75.75 0 0 0 0-1.129A60.542 60.542 0 0 0 3.478 2.405Z" />
                    </svg>
                </button>
            </div>
        </footer>
    </div>

    <script>
        // Global state variables
        let currentChatId = null;
        let allChats = {}; // Stores { chatId: [messages] }
        let messages = []; // Messages for the current active chat
        let selectedImage = null; // Staged image
        let isLoading = false;
        let isProcessingImage = false;
        let isSidebarOpen = false;
        let isRecording = false; // State for microphone recording
        let isVoiceInputActive = false; // Flag to track if last input was voice

        // Web Speech API variables
        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let SpeechSynthesisUtterance = window.SpeechSynthesisUtterance;
        let recognition = null;
        let synth = window.speechSynthesis;

        // DOM element references
        const sidebar = document.getElementById('sidebar');
        const sidebarOpenButton = document.getElementById('sidebar-open-button');
        const sidebarCloseButton = document.getElementById('sidebar-close-button');
        const newChatButton = document.getElementById('new-chat-button');
        const historyList = document.getElementById('history-list');
        const chatMessagesContainer = document.getElementById('chat-messages-container');
        const initialMessageDiv = document.getElementById('initial-message');
        const stagedImagePreviewContainer = document.getElementById('staged-image-preview-container');
        const fileInput = document.getElementById('file-input');
        const addMediaButton = document.getElementById('add-media-button');
        const micButton = document.getElementById('mic-button'); // New microphone button
        const inputTextarea = document.getElementById('input-textarea');
        const sendButton = document.getElementById('send-button');
        const searchHistoryInput = document.getElementById('search-history-input'); // New search input
        const languageSelect = document.getElementById('language-select'); // New language select
        const darkModeToggle = document.getElementById('dark-mode-toggle'); // New dark mode toggle
        const sunIcon = darkModeToggle.querySelector('.sun-icon');
        const moonIcon = darkModeToggle.querySelector('.moon-icon');

        // Helper to generate a unique ID
        const generateUUID = () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // Function to format timestamp
        const formatTimestamp = (isoString) => {
            const date = new Date(isoString);
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const formattedHours = hours % 12 || 12; // 12-hour format
            const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;
            return `${formattedHours}:${formattedMinutes} ${ampm}`;
        };

        // Scroll to the bottom of the chat
        const scrollToBottom = () => {
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
        };

        // Save chats to local storage
        const saveChatsToLocalStorage = () => {
            if (currentChatId) {
                allChats[currentChatId] = messages;
                localStorage.setItem('aiChatbotAllChats', JSON.stringify({
                    currentChatId: currentChatId,
                    chats: allChats
                }));
            }
        };

        // Function to handle new chat
        const handleNewChat = () => {
            const newId = generateUUID();
            currentChatId = newId;
            messages = []; // Clear messages for the new chat
            selectedImage = null; // Clear any staged image
            inputTextarea.value = ''; // Clear input
            isSidebarOpen = false; // Close sidebar
            isVoiceInputActive = false; // Reset voice input flag
            renderAllUI(); // Re-render the UI
        };

        // Function to handle loading an existing chat
        const handleLoadChat = (chatId) => {
            if (allChats[chatId]) {
                currentChatId = chatId;
                messages = allChats[chatId];
                selectedImage = null; // Clear any staged image
                inputTextarea.value = ''; // Clear input
                isSidebarOpen = false; // Close sidebar
                isVoiceInputActive = false; // Reset voice input flag
                renderAllUI(); // Re-render the UI
            }
        };

        // Function to handle deleting a chat
        const handleDeleteChat = (chatIdToDelete) => {
            // Confirm deletion
            if (!confirm("Are you sure you want to delete this chat?")) {
                return;
            }

            delete allChats[chatIdToDelete];

            // If the deleted chat was the current one, switch to a new chat
            if (currentChatId === chatIdToDelete) {
                const remainingChatIds = Object.keys(allChats);
                if (remainingChatIds.length > 0) {
                    handleLoadChat(remainingChatIds[0]); // Load first available chat
                } else {
                    handleNewChat(); // No chats left, create a new one
                }
            }
            renderAllUI(); // Re-render the UI
        };

        // Load chats from local storage
        const loadChatsFromLocalStorage = () => {
            try {
                const storedData = localStorage.getItem('aiChatbotAllChats');
                if (storedData) {
                    const parsedData = JSON.parse(storedData);
                    allChats = parsedData.chats || {};
                    if (parsedData.currentChatId && allChats[parsedData.currentChatId]) {
                        currentChatId = parsedData.currentChatId;
                        messages = allChats[parsedData.currentChatId];
                    } else {
                        handleNewChat(); // If no current chat or invalid, create a new one
                    }
                } else {
                    handleNewChat(); // No chats found, create the first one
                }
            } catch (error) {
                console.error("Failed to load chats from localStorage:", error);
                handleNewChat(); // Fallback to new chat on error
            }
            renderAllUI();
        };

        // Render functions to update UI based on state
        const renderChatMessages = () => {
            chatMessagesContainer.innerHTML = ''; // Clear current messages
            if (messages.length === 0 && !isLoading) {
                initialMessageDiv.style.display = 'block';
                chatMessagesContainer.appendChild(initialMessageDiv);
            } else {
                initialMessageDiv.style.display = 'none';
                messages.forEach((msg, index) => {
                    const messageWrapper = document.createElement('div');
                    messageWrapper.className = `flex items-start space-x-3 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`;

                    // Avatar
                    const avatarDiv = document.createElement('div');
                    avatarDiv.className = `flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold ${
                        msg.role === 'user' ? 'bg-blue-500 text-white order-2' : 'bg-gray-400 text-gray-900 order-1 dark:bg-gray-600 dark:text-gray-100'
                    }`;
                    avatarDiv.textContent = msg.role === 'user' ? 'You' : 'AI';

                    const contentDiv = document.createElement('div');
                    contentDiv.className = `max-w-[75%] p-4 rounded-xl shadow-md ${
                        msg.role === 'user'
                            ? 'bg-blue-500 text-white rounded-br-none dark:bg-blue-700'
                            : 'bg-gray-200 text-gray-800 rounded-bl-none border border-gray-300 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600'
                    } break-words`;

                    if ((msg.type === 'text' || msg.type === 'mixed') && msg.text) {
                        const textContent = document.createElement('div');
                        textContent.innerHTML = marked.parse(msg.text);
                        contentDiv.appendChild(textContent);
                    }

                    if ((msg.type === 'image' || msg.type === 'mixed') && msg.data) {
                        const img = document.createElement('img');
                        img.src = msg.data;
                        img.alt = "User uploaded";
                        img.className = "max-w-full h-auto rounded-lg shadow-sm mt-2";
                        img.onload = scrollToBottom;
                        img.onerror = (e) => { e.target.onerror = null; e.target.src="https://placehold.co/150x150/cccccc/000000?text=Image+Error"; };
                        contentDiv.appendChild(img);
                    }

                    // Timestamp
                    const timestampSpan = document.createElement('span');
                    timestampSpan.className = `text-xs mt-1 ${msg.role === 'user' ? 'text-blue-200 dark:text-blue-300' : 'text-gray-500 dark:text-gray-400'} block text-right`;
                    timestampSpan.textContent = formatTimestamp(msg.timestamp);
                    contentDiv.appendChild(timestampSpan);

                    // Delete button for user messages
                    if (msg.role === 'user') {
                        const deleteButton = document.createElement('button');
                        deleteButton.className = "absolute top-1 right-1 p-1 rounded-full bg-red-500 text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity duration-200";
                        deleteButton.title = "Delete message";
                        deleteButton.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" class="w-4 h-4">
                                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        `;
                        deleteButton.onclick = (e) => {
                            e.stopPropagation();
                            if (confirm("Are you sure you want to delete this message?")) {
                                messages.splice(index, 1); // Remove message by index
                                renderAllUI();
                            }
                        };
                        contentDiv.classList.add('relative', 'group'); // Add group class for hover effect
                        contentDiv.appendChild(deleteButton);
                    }


                    if (msg.role === 'user') {
                        messageWrapper.appendChild(contentDiv);
                        messageWrapper.appendChild(avatarDiv);
                    } else {
                        messageWrapper.appendChild(avatarDiv);
                        messageWrapper.appendChild(contentDiv);
                    }
                    chatMessagesContainer.appendChild(messageWrapper);
                });
            }
            scrollToBottom();
        };

        const renderSidebar = () => {
            historyList.innerHTML = '';
            const searchTerm = searchHistoryInput.value.toLowerCase();
            const filteredChatIds = Object.keys(allChats).filter(chatId => {
                const firstMessageText = allChats[chatId][0]?.text?.toLowerCase() || '';
                return firstMessageText.includes(searchTerm);
            });

            if (filteredChatIds.length === 0) {
                const noHistory = document.createElement('p');
                noHistory.className = "text-gray-400 text-sm p-3 text-center";
                noHistory.textContent = "No chat history yet or no results found.";
                historyList.appendChild(noHistory);
            } else {
                filteredChatIds.forEach(chatId => {
                    const chatItem = document.createElement('div');
                    chatItem.className = `flex items-center justify-between p-3 rounded-lg mb-2 cursor-pointer hover:bg-gray-700 transition duration-150 ${currentChatId === chatId ? 'bg-gray-700 ring-2 ring-blue-500' : 'bg-gray-600'} dark:hover:bg-gray-800 dark:bg-gray-800 ${currentChatId === chatId ? 'dark:ring-blue-500' : ''}`;

                    const chatTitleSpan = document.createElement('span');
                    chatTitleSpan.className = "flex-1 text-sm truncate";
                    chatTitleSpan.title = allChats[chatId][0]?.text || `Chat ${chatId.substring(0, 8)}`; // Show full text on hover
                    chatTitleSpan.textContent = allChats[chatId][0]?.text ? allChats[chatId][0].text.substring(0, 25) + (allChats[chatId][0].text.length > 25 ? '...' : '') : `Chat ${chatId.substring(0, 8)}`;
                    chatTitleSpan.onclick = () => handleLoadChat(chatId);

                    const deleteButton = document.createElement('button');
                    deleteButton.className = "ml-2 p-1 rounded-full hover:bg-red-500 text-gray-300 hover:text-white transition duration-150";
                    deleteButton.title = "Delete Chat";
                    deleteButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" class="w-5 h-5">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.927a2.25 2.25 0 01-2.244-2.077L4.747 6.75M9.257 4.5H15.75m-1.5 0H5.25c-.811 0-1.607.083-2.363.233A2.25 2.25 0 001.5 4.573V6.25c0 .58.287 1.128.743 1.465L5.75 9.75m0 0h12.5m0 0l-1.5 1.5m-1.5 1.5l-1.5 1.5M18.75 6.75v14.25c0 1.242-.968 2.25-2.167 2.25H7.417C6.218 23.25 5.25 22.242 5.25 21V6.75m13.5 0c.276 0 .5.224.5.5v.75" />
                        </svg>
                    `;
                    deleteButton.onclick = (e) => { e.stopPropagation(); handleDeleteChat(chatId); };

                    chatItem.appendChild(chatTitleSpan);
                    chatItem.appendChild(deleteButton);
                    historyList.appendChild(chatItem);
                });
            }
        };

        const renderStagedImagePreview = () => {
            stagedImagePreviewContainer.innerHTML = '';
            if (selectedImage) {
                const previewDiv = document.createElement('div');
                previewDiv.className = "relative mb-3 p-2 border border-gray-300 rounded-lg bg-gray-50 flex items-center justify-between dark:bg-gray-700 dark:border-gray-600";
                previewDiv.innerHTML = `
                    <img src="${selectedImage}" alt="Selected for input" class="max-h-24 rounded-md object-contain" />
                    <button id="remove-staged-image-button" class="absolute top-1 right-1 p-1 bg-red-500 text-white rounded-full text-xs hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500" title="Remove image">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" class="w-4 h-4">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                `;
                stagedImagePreviewContainer.appendChild(previewDiv);
                document.getElementById('remove-staged-image-button').onclick = () => {
                    selectedImage = null;
                    renderAllUI(); // Re-render to remove preview
                };
            }
        };

        const updateLoadingState = () => {
            let loadingIndicator = document.getElementById('loading-indicator');
            let processingImageIndicator = document.getElementById('processing-image-indicator');

            if (isLoading) {
                if (!loadingIndicator) {
                    const div = document.createElement('div');
                    div.id = 'loading-indicator';
                    div.className = "flex justify-center mt-4";
                    div.innerHTML = `
                        <div class="flex items-center space-x-2 text-gray-600 bg-white p-3 rounded-lg shadow-md dark:bg-gray-700 dark:text-gray-300">
                            <div class="w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                            <span class="font-medium">AI Chatbot is thinking...</span>
                        </div>
                    `;
                    chatMessagesContainer.appendChild(div);
                }
            } else {
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            }

            if (isProcessingImage) {
                 if (!processingImageIndicator) {
                    const div = document.createElement('div');
                    div.id = 'processing-image-indicator';
                    div.className = "flex justify-center mt-4";
                    div.innerHTML = `
                        <div class="flex items-center space-x-2 text-gray-600 bg-white p-3 rounded-lg shadow-md dark:bg-gray-700 dark:text-gray-300">
                            <div class="w-5 h-5 border-2 border-green-500 border-t-transparent rounded-full animate-spin"></div>
                            <span class="font-medium">Processing image...</span>
                        </div>
                    `;
                    chatMessagesContainer.appendChild(div);
                }
            } else {
                if (processingImageIndicator) {
                    processingImageIndicator.remove();
                }
            }

            // Disable input and buttons based on state
            const disableAll = isLoading || isProcessingImage || isRecording;
            sendButton.disabled = disableAll || (!inputTextarea.value.trim() && !selectedImage);
            inputTextarea.disabled = disableAll;
            addMediaButton.disabled = disableAll;
            micButton.disabled = isLoading || isProcessingImage; // Mic button disabled only during AI thinking or image processing
            micButton.classList.toggle('bg-purple-500', !isRecording); // Updated color for mic button off state
            micButton.classList.toggle('bg-pink-500', isRecording); // Updated color for mic button on state
        };

        const toggleSidebar = () => {
            isSidebarOpen = !isSidebarOpen;
            if (isSidebarOpen) {
                sidebar.classList.remove('-translate-x-full');
                sidebar.classList.add('translate-x-0');
            } else {
                sidebar.classList.remove('translate-x-0');
                sidebar.classList.add('-translate-x-full');
            }
        };

        // Dark Mode Logic
        const toggleDarkMode = () => {
            document.documentElement.classList.toggle('dark');
            const isDarkMode = document.documentElement.classList.contains('dark');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            updateDarkModeIcons(isDarkMode);
        };

        const updateDarkModeIcons = (isDarkMode) => {
            if (isDarkMode) {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
        };

        // Initialize theme from local storage
        const initializeTheme = () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
                updateDarkModeIcons(true);
            } else {
                document.documentElement.classList.remove('dark');
                updateDarkModeIcons(false);
            }
        };


        // Main render function to update all dynamic parts of the UI
        const renderAllUI = () => {
            renderChatMessages();
            renderSidebar();
            renderStagedImagePreview();
            updateLoadingState();
            saveChatsToLocalStorage(); // Save state after every UI update
        };

        // Function to handle sending messages to the API
        const handleSendMessage = async () => {
            const hasTextMessage = inputTextarea.value.trim().length > 0;
            const hasStagedImage = selectedImage !== null;

            if ((!hasTextMessage && !hasStagedImage) || isLoading || isProcessingImage) {
                return;
            }

            isLoading = true;
            renderAllUI(); // Show loading indicator immediately

            let userMessageForDisplay = {
                role: 'user',
                timestamp: new Date().toISOString(),
                text: hasTextMessage ? inputTextarea.value.trim() : '',
                data: hasStagedImage ? selectedImage : null,
                type: 'text',
            };

            if (hasTextMessage && hasStagedImage) {
                userMessageForDisplay.type = 'mixed';
            } else if (hasStagedImage) {
                userMessageForDisplay.type = 'image';
            }

            // Add the user's message to the current chat's messages
            messages.push(userMessageForDisplay);
            renderAllUI(); // Render user message immediately

            // Clear input and staged image after adding to messages
            inputTextarea.value = '';
            inputTextarea.style.height = 'auto'; // Reset textarea height
            selectedImage = null;
            renderAllUI(); // Update UI to clear input and staged image

            // Prepare chat history for Gemini API call
            const chatHistoryForApi = [];
            messages.forEach(msg => {
                if (msg.role === 'model') {
                    chatHistoryForApi.push({ role: msg.text ? msg.role : 'user', parts: [{ text: msg.text }] }); // Ensure text part is present
                } else if (msg.role === 'user') {
                    const userParts = [];
                    if (msg.type === 'text' || msg.type === 'mixed') {
                        userParts.push({ text: msg.text });
                    }
                    if ((msg.type === 'image' || msg.type === 'mixed') && msg.data) {
                        const base64Data = msg.data.split(',')[1];
                        const mimeType = msg.data.split(',')[0].split(':')[1].split(';')[0];
                        userParts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
                    }
                    if (userParts.length > 0) {
                        chatHistoryForApi.push({ role: msg.role, parts: userParts });
                    }
                }
            });

            const payload = { contents: chatHistoryForApi };
 ////Dont copy this.instead create you own for free in google ai studio.it is in free tier.
            const apiKey = "AIzaSyBl5fGiL7eb8zvrZexCdO1oPVwtTQVm8L8";             

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();

                let geminiResponseText = "No response from AI Chatbot.";
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    geminiResponseText = result.candidates[0].content.parts[0].text;
                } else {
                    console.warn("Unexpected Gemini API response structure:", result);
                }

                const geminiMessage = {
                    role: 'model',
                    type: 'text',
                    text: geminiResponseText,
                    timestamp: new Date().toISOString()
                };

                messages.push(geminiMessage);
                renderAllUI(); // Render Gemini's response

                // Speak the AI's response ONLY if the last input was from voice
                if (isVoiceInputActive) {
                    speakText(geminiResponseText);
                }

            } catch (error) {
                console.error("Error sending message or getting Gemini response:", error);
                const errorMessage = {
                    role: 'model',
                    type: 'text',
                    text: `Error: Could not get a response. ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                messages.push(errorMessage);
                renderAllUI(); // Render error message
                // Speak the error only if voice input was active
                if (isVoiceInputActive) {
                    speakText(`Error: ${error.message}`);
                }
            } finally {
                isLoading = false;
                // Important: Reset isVoiceInputActive after AI response is handled
                // This ensures subsequent typed inputs don't trigger voice output.
                isVoiceInputActive = false;
                renderAllUI(); // Hide loading indicator
            }
        };

        // Speech Recognition (Voice Input) Logic
        const startRecognition = () => {
            if (!SpeechRecognition) {
                alert("Speech Recognition not supported in this browser. Please use Chrome or Edge.");
                return;
            }

            if (recognition) {
                recognition.stop(); // Stop any ongoing recognition
            }

            recognition = new SpeechRecognition();
            recognition.lang = languageSelect.value; // Use selected language
            recognition.interimResults = false; // Only return final results
            recognition.maxAlternatives = 1; // Get the most likely result

            recognition.onstart = () => {
                isRecording = true;
                isVoiceInputActive = true; // Set flag when voice input starts
                inputTextarea.placeholder = "Listening...";
                inputTextarea.value = ''; // Clear input area on start
                renderAllUI();
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                inputTextarea.value = transcript;
                inputTextarea.dispatchEvent(new Event('input')); // Trigger input event to resize textarea
                isRecording = false;
                inputTextarea.placeholder = "Type your message...";
                renderAllUI();
                // Automatically send message after recognition
                handleSendMessage();
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                alert(`Speech recognition error: ${event.error}. Please ensure microphone access is granted.`);
                isRecording = false;
                isVoiceInputActive = false; // Reset flag on error
                inputTextarea.placeholder = "Type your message...";
                renderAllUI();
            };

            recognition.onend = () => {
                if (isRecording) { // If it ended without a result (e.g., silence)
                    isRecording = false;
                    isVoiceInputActive = false; // Reset flag if recognition ends without result
                    inputTextarea.placeholder = "Type your message...";
                    renderAllUI();
                }
            };

            try {
                recognition.start();
            } catch (e) {
                console.error("Error starting speech recognition:", e);
                alert("Could not start speech recognition. Please check microphone permissions.");
                isRecording = false;
                isVoiceInputActive = false; // Reset flag on error
                inputTextarea.placeholder = "Type your message...";
                renderAllUI();
            }
        };

        // Speech Synthesis (Voice Output) Logic
        const speakText = (text) => {
            if (!SpeechSynthesisUtterance || !synth) {
                console.warn("Speech Synthesis not supported in this browser.");
                return;
            }

            // Stop any ongoing speech
            synth.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = languageSelect.value; // Use selected language
            utterance.rate = 1; // Speed of speech
            utterance.pitch = 1; // Pitch of voice

            // Optional: Choose a specific voice if available
            // let voices = synth.getVoices();
            // let selectedVoice = voices.find(voice => voice.lang === languageSelect.value || voice.lang.startsWith(languageSelect.value.substring(0,2)));
            // if (selectedVoice) {
            //     utterance.voice = selectedVoice;
            // }

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
            };

            synth.speak(utterance);
        };


        // Event Listeners
        newChatButton.addEventListener('click', handleNewChat);
        sidebarOpenButton.addEventListener('click', toggleSidebar);
        sidebarCloseButton.addEventListener('click', toggleSidebar);
        micButton.addEventListener('click', startRecognition); // Attach to mic button
        darkModeToggle.addEventListener('click', toggleDarkMode); // Attach dark mode toggle
        languageSelect.addEventListener('change', () => {
            // When language changes, if recording, stop and restart with new language
            if (isRecording && recognition) {
                recognition.stop();
                startRecognition();
            }
        });

        searchHistoryInput.addEventListener('input', renderSidebar); // Live search filtering

        addMediaButton.addEventListener('click', () => {
            isVoiceInputActive = false; // Reset flag when media button is clicked
            fileInput.click();
        });
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                const file = files[0];
                if (!file.type.startsWith('image/')) {
                    console.warn("Selected file is not an image:", file.type);
                    alert("Please select an image file.");
                    return;
                }

                isProcessingImage = true;
                renderAllUI(); // Update UI to show processing indicator
                const reader = new FileReader();
                reader.onloadend = () => {
                    selectedImage = reader.result; // Stage the image
                    isProcessingImage = false;
                    fileInput.value = null; // Clear input value
                    renderAllUI(); // Re-render to show staged image
                };
                reader.onerror = (error) => {
                    console.error("Error reading file:", error);
                    alert("Failed to read image file.");
                    isProcessingImage = false;
                    fileInput.value = null;
                    renderAllUI(); // Re-render to hide processing indicator
                };
                reader.readAsDataURL(file); // Read file as Base64 Data URL
            }
        });

        inputTextarea.addEventListener('input', () => {
            inputTextarea.style.height = 'auto';
            inputTextarea.style.height = inputTextarea.scrollHeight + 'px';
            isVoiceInputActive = false; // Reset flag when text is manually typed
            updateLoadingState(); // Update send button state
        });

        inputTextarea.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendMessage();
            }
        });

        sendButton.addEventListener('click', handleSendMessage);

        // Initialize the application on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme(); // Initialize theme first
            loadChatsFromLocalStorage();
        });
    </script>
</body>
</html>
